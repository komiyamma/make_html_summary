
<div class="content-box mb-3 content-lighten">
<h2><i class="fa fa-book fa-fw"></i>秀丸を閉じる時に実行する関数 (秀丸エディタ 8.98以上)</h2>
</div>
<div class="content-box mb-3 content-lighten">
        <h3>概要</h3>
        <p>C#で作成したdllは非同期処理などを含むことができますので、<br>
        「秀丸を閉じる」際などに、「スレッドを止める」あるいは「ファイルに書き込む」など必要な処理を行う必要があるような<br>
    dllを作成したいと思うこともあるでしょう。<br>
秀丸エディタ 8.98以上ならば、COM呼び出しに対して、オブジェクト解放時にメソッドを指定して実行させることが出来ます。</p>
</div>
<div class="content-box mb-3 content-lighten">
    <h3>public void ***(int reason=0) 型のメソッドを終了時用のメソッドとして定義</h3>
    <p>reasonには、どういった理由で解放されたのかの番号が渡ってきます。</p>
    <fieldset class="code">
        <legend>NET4COMServer.cs</legend><pre class="brush:csharp;highlight:[8,15,16,17,18]">using System;
using System.Runtime.InteropServices;
using HmNetCOM;

namespace NET4COMServer
{
    [Guid("BD55F2A6-9ED0-4F4F-9D37-E6B84BE63272")]
    public class NET4COMServer : Hm.IComDetachMethod
    {
        public int add(int a, int b)
        {
            return a + b;
        }

        public void OnReleaseObject(int reason=0)
        {
            System.Diagnostics.Trace.WriteLine("Hidemaru NET4 COM Server Dispose");
        }
    }
}
</pre>
</fieldset>
</div>

<div class="content-box mb-3 content-lighten">
    <h3>呼び出し側</h3>
    <p><span class="negative">「setcomdetachmethod」と「keepobject」</span>で、終了時のメソッドを指定しつつも、プロセスが終了するまでオブジェクトをキープすることとなります。<br>
        (※ keepobjectを記述しなかった場合は、マクロ終了時に自動的に、setcomdetachmethod で指定したメソッドが呼ばれます。)</p>
        <fieldset class="code">
        <legend>NET4COMServer.mac</legend><pre class="brush:hmmacro;">#obj = createobject( currentmacrodirectory + @"\NET4COMServer.dll", "NET4COMServer.NET4COMServer");
keepobject #obj, 1;
setcomdetachmethod #obj, "OnReleaseObject";
#add = member(#obj, "add", 100, 200);

// 秀丸のプロセスを閉じた際に、C#のOnReleaseObjectが実行される。複数回マクロを実行した場合には秀丸を閉じた際にまとめて実行される。
</pre>
</fieldset>
</div>

<div class="content-box mb-3 content-lighten">
    <h3>呼び出し側</h3>
    <p>同じマクロを何度も実行した際、どんどんオブジェクトが蓄積されるのではなく、「（同じプロセスの）１つ前に生成したもの」は「Dispose」したい、といった場合には以下のようにすれば良いでしょう。</p>
        <fieldset class="code">
        <legend>NET4COMServer.mac</legend><pre class="brush:hmmacro;">// 前のマクロ実行時に「NET4COMServer.NET4COMServer」型のCOMオブジェクトが残っているならば、先にすべてリリースする。
// 20というのは適当な数。(１つのマクロで20個以上COMオブジェクトを作ることは極めてまれだろうという前提の数。)
#HmmacCOMRef = 1;
while(#HmmacCOMRef &lt; 20) {
    // .NETのクラスはObjectを継承するため、必ずToStringを継承している。
    // 特別に上書きでもしていない限り、ユーザー定義のクラスなら、ToStringメソッドにより、名前空間+クラス名が文字列として帰ってくる。
    if (member(#HmmacCOMRef, "ToString") == "NET4COMServer.NET4COMServer") {
        releaseobject #HmmacCOMRef;
    }
    #HmmacCOMRef = #HmmacCOMRef + 1;
}

#obj = createobject( currentmacrodirectory + @"\NET4COMServer.dll", "NET4COMServer.NET4COMServer");
keepobject #obj, 1;
setcomdetachmethod #obj, "OnReleaseObject";
#add = member(#obj, "add", 100, 200);
</pre>
</fieldset>
</div>

<div class="content-box mb-3 content-lighten">
    <h3>.NET Framework 4.xの場合
    </h3>
    <p><a href="?page=nobu_tool_hm_dotnet_macro_com_destroy_method">こちら</a>にも同様の解説ページを用意しています。</p>
</div>

<div class="content-box mb-3 content-lighten">
    <h3>.NET5、.NET6、や .NET Core 3.1の場合
    </h3>
    <p><a href="?page=nobu_tool_hm_dotnet_macro_com5_destroy_method">こちら</a>にも同様の解説ページを用意しています。</p>
</div>